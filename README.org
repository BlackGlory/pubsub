* PubSub
一个受[[https://patchbay.pub/][patchbay]], [[https://smee.io/][smee.io]], [[https://github.com/sensiblecodeio/hookbot][hookbot]]启发的Web友好的自托管ad-hoc微服务,
提供基于 HTTP, SSE 和 WebSocket 的 PubSub 功能.

受原理所限, 此服务不能实现消息的可靠传递(reliable delivery), 也无法重发消息.
因此当遭遇网络故障时, 消息可能会丢失.

所有URL都采用了反射性的CORS, 不提供针对 =Origin= 的访问控制策略.

** Quickstart
- sse-cat: https://github.com/BlackGlory/sse-cat
- websocat: https://github.com/vi/websocat

#+BEGIN_SRC sh
# 运行-
docker run --detach --publish 8080:8080 blackglory/pubsub

# 打开第一个终端
sse-cat http://localhost:8080/pubsub/hello-world

# 打开第二个终端
websocat ws://localhost:8080/pubsub/hello-world

# 打开第三个终端
curl http://localhost:8080/pubsub/hello-world --data 'hello'
#+END_SRC

** Install
*** 从源代码运行
可以使用环境变量 =PUBSUB_HOST= 和 =PUBSUB_PORT= 决定服务器监听的地址和端口, 默认值为localhost和8080.

#+BEGIN_SRC sh
git clone https://github.com/BlackGlory/pubsub
cd pubsub
yarn install
yarn build
yarn bundle
yarn --silent start
#+END_SRC

*** Docker

#+BEGIN_SRC sh
docker run \
  --detach \
  --publish 8080:8080 \
  blackglory/pubsub
#+END_SRC

**** 从源代码构建
#+BEGIN_SRC sh
git clone https://github.com/BlackGlory/pubsub
cd pubsub
yarn install
yarn docker:build
#+END_SRC

**** Recipes
***** 公开服务器
****** docker-compose.yml
#+BEGIN_SRC yaml
version: '3.8'

services:
  pubsub:
    image: 'blackglory/pubsub'
    restart: always
    volumes:
      - 'pubsub-data:/data'
    ports:
      - '8080:8080'

volumes:
  pubsub-data:
#+END_SRC

***** 私人服务器
****** docker-compose.yml
#+BEGIN_SRC yaml
version: '3.8'

services:
  pubsub:
    image: 'blackglory/pubsub'
    restart: always
    volumes:
      - 'pubsub-data:/data'
    ports:
      - '8080:8080'

volumes:
  pubsub-data:
#+END_SRC

** API
所有API中的namespace都需要满足此正则表达式: `^[a-zA-Z0-9\.\-_]{0,255}$`

*** Public
**** publish
=POST /pubsub/<namespace>=

往特定频道发布消息, 所有订阅此频道的客户端都会收到消息.
namespace用于标识频道.

如果开启基于token的访问控制, 则可能需要在Querystring提供具有write权限的token:
=POST /pubsub/<namespace>?token=<token>=

***** Example
****** curl
#+BEGIN_SRC sh
curl \
  --data 'message' \
  "http://localhost:8080/pubsub/$namespace"
#+END_SRC

****** JavaScript
#+BEGIN_SRC js
fetch(`http://localhost:8080/pubsub/${namespace}`, {
  method: 'POST'
, body: 'message'
})
#+END_SRC

**** subscribe via Server-Sent Events(SSE)
=GET /pubsub/<namespace>=

通过SSE订阅特定频道.
namespace用于标识频道.

当客户端主要是浏览器时, 强烈建议服务器提供 HTTP/2 协议的反向代理.

如果开启基于token的访问控制, 则可能需要在Querystring提供具有read权限的token:
=/pubsub/<namespace>?token=<token>=

***** heartbeat
通过环境变量 =PUBSUB_SSE_HEARTBEAT_INTERVAL= 可以设置SSE心跳包的发送间隔, 单位为毫秒.
在默认情况下, 服务不会发送SSE心跳包,
半开连接的检测依赖于服务端和客户端的运行平台的TCP Keepalive配置.

当 =PUBSUB_SSE_HEARTBEAT_INTERVAL= 大于零时,
服务会通过SSE的heartbeat事件按指定间隔发送空白数据.
客户端若要实现半开连接检测, 则需要自行根据heartbeat事件设定计时器, 以判断连接是否正常.

***** Example
****** sse-cat
#+BEGIN_SRC sh
sse-cat "http://localhost:8080/pubsub/$namespace"
#+END_SRC

****** JavaScript
#+BEGIN_SRC js
const es = new EventSource(`http://localhost:8080/pubsub/${namespace}`)
es.addEventListener('message', event => {
  console.log(event.data)
})
#+END_SRC

**** subscribe via WebSocket
=WS /pubsub/<namespace>=

通过WebSocket订阅特定频道.
namespace用于标识频道.

如果开启基于token的访问控制, 则可能需要在Querystring提供具有read权限的token:
=/pubsub/<namespace>?token=<token>=

***** heartbeat
通过环境变量  =PUBSUB_WS_HEARTBEAT_INTERVAL= 可以设置WS心跳包(ping帧)的发送间隔, 单位为毫秒.
在默认情况下, 服务不会发送心跳包,
半开连接的检测依赖于服务端和客户端的运行平台的TCP Keepalive配置.

当 =PUBSUB_WS_HEARTBEAT_INTERVAL= 大于零时,
服务会通过WS的ping帧按间隔发送心跳包.

客户端若要实现半开连接检测, 可以定期发送空白字符串到服务端, 以判断连接是否正常.
为防止带宽滥用, 如果客户端发送的不是空白字符串, 则服务端会主动关闭连接.

***** Example
****** websocat
#+BEGIN_SRC sh
websocat "ws://localhost:8080/pubsub/$namespace"
#+END_SRC

****** JavaScript
#+BEGIN_SRC js
const ws = new WebSocket(`ws://localhost:8080/pubsub/${namespace}`)
ws.addEventListener('message', event => {
    console.log(event.data);
})
#+END_SRC

** Webhook
PubSub的publish端点可用于Webhook,
但它不会转发请求头, IP地址等信息, 因此无法用于需要这些信息的场景.

在此项目的早期阶段, 曾设计过一个 =/pubsub/<namespace>/webhook= 端点,
该端点会生成包含必要信息的新JSON.
但随即便发现它无法与基于JSON Schema的JSON验证进行整合, 也无法防止伪造消息.
解决这些问题需要单独为Webhook创建新的数据库表和API接口,
这为PubSub添加了过多的职责, 严重增加了项目的复杂性, 因此该设计被放弃.

建议的解决方案是为Webhook单独创建HTTP服务器, 生成包含所需信息的请求, 将其发送给PubSub.
在这种情况下, 可以通过添加具有publish权限的token的方式, 防止伪造请求.
